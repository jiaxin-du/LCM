//-------------------------------------------------
//
//          Laminar cortex model
//
// Developed by Jiaxin Du under the supervision of
//    Prof. David Reutens and Dr. Viktor Vegh
//
//       Centre for Advanced Imaging (CAI),
//   The University of Queensland (UQ), Australia
//
//        jiaxin.du@uqconnect.edu.au
//
// Reference:
//  Du J, Vegh V, & Reutens DC,
//                PLOS Compt Biol 8(10): e1002733.
//              & NeuroImage 94: 1-11.
//
// See README for software copyright statements.
//-------------------------------------------------
#include "neurgrp.h"

using namespace std;

//initial global counter for neuron groups
TInt NeurGrp::NG_cnt = 0;

const char* NeurGrp::NG_ParamName[NG_PARA_NUM] = { \
   "DENSITY", "PSP_SPEED", "SPK_SPEED", "PSP_DECAY", "SYNP_SIGMA", "V_REV", "V_0", "FIRE_GAIN", "FIRE_VHMF", "FIRE_MAX", "TAU_MBN" \
};
const TReal NeurGrp::NG_ParamMin[NG_PARA_NUM] = { \
           0,           0,           0,           0,            0,    -200,  -200,           0,      -200,           0,        0 \
};
const TReal NeurGrp::NG_ParamMax[NG_PARA_NUM] = { \
             1e20,          100,        100,        1000,         1000,     200,   200,          100,      200,        10000,    1000 \
};

NeurGrp::NeurGrp(const string& xname, const TInt& idx) :
    SpikeSrc(xname, idx),
    _ng_paramVal(NG_PARA_NUM, 0),
    _ng_mp_decay_step(0),
    _ng_layer(-1),
    _ng_type(cNaN),
    _ng_paramFlg(NG_PARA_NUM, false),
    _ng_state(false)
{
    ++NG_cnt;
}

NeurGrp::NeurGrp(const NeurGrp& p)
{
    *this = p;

    ++NG_cnt;
}


NeurGrp::~NeurGrp(void)
{
    --NG_cnt;
}

//assignment operator
//NeurGrp& NeurGrp::operator= (const NeurGrp& p)
//{
//   if (this != &p) {
//
//      SpikeSrc::operator=(p);
//
//      _ng_type = p._ng_type;
//
//      _ng_layer = p._ng_layer;
//
//      _ng_state = p._ng_state;
//
//      _ng_paramFlg = p._ng_paramFlg;
//      _ng_paramFlg = p._ng_paramFlg;
//
//   }
//
//   return *this;
//}

bool NeurGrp::set_param(const string& paramName, const TReal& val)
{
    for (TInt iparam = 0; iparam < NG_PARA_NUM; iparam++) {
        if (paramName == NG_ParamName[iparam]) {
            if (val<NG_ParamMin[iparam] || val>NG_ParamMax[iparam]) {
                cerr << name() << ": " << msg_invalid_param_value(paramName, val) << endl;
                cerr << "   the allowed range is [" << NG_ParamMin[iparam] << ", " << NG_ParamMax[iparam] << "]" << endl;
                return false;
            }
            _ng_paramVal[iparam] = val;
            _ng_paramFlg[iparam] = true;
            _ng_state = false;
            return true;
        }
    }

    cerr << name() << ":: " << msg_invalid_param_name(paramName) << endl;
    return false;
}

bool NeurGrp::set_param(const TInt& iparam, const TReal& val)
{

    if (val<NG_ParamMin[iparam] || val>NG_ParamMax[iparam]) {
        cerr << name() << ": " << msg_invalid_param_value(NG_ParamName[iparam], val) << endl;
        cerr << "   the allowed range is [" << NG_ParamMin[iparam] << ", " << NG_ParamMax[iparam] << "]" << endl;
        return false;
    }
    _ng_paramVal[iparam] = val;
    _ng_paramFlg[iparam] = true;
    _ng_state = false;
    return true;
}

bool NeurGrp::set_type(const TNeur& xtype)
{
    if (xtype == cNaN) return false;
    _ng_type = xtype;
    return true;
}

bool NeurGrp::set_layer(const TInt& xlayer)
{
    _ng_layer = xlayer;
    return true;
}

//-------------------------------------------------
// function: TReal NeurGrp::eqn_Q(const TReal &V)
//    Nueronal firing function
//    input: membrane potential of a neuron group
//    output: spike rate generated by the neuron groups
//
//    Q_q  = Q_max / ( 1 + exp(-k * (V_q - V_VHMF) )
//   
//    where
//   
//    k is the firing gain, and V_VHMF is the voltage at 
//    half maximum firing rate, Q_max is the maximum
//    firing rate
//-------------------------------------------------
TReal NeurGrp::eqn_firing(const TReal &V) const
{
    assert(_ng_state);
    //if(V <= V_0()) return 0.;
    return fire_max() / (1. + exp(fire_gain() * (fire_VHMF() - V)));
}

void NeurGrp::swap(NeurGrp& p)
{
    if (&p == this) return;

    NeurGrp tmp = p;
    p = *this;
    *this = tmp;
}

void NeurGrp::init(const TReal& time_step)
{
    SpikeSrc::init();

    if (type() == cNaN || layer() < 0) return;
    for (TInt iparam = 0; iparam < NG_PARA_NUM; iparam++) {
        if (!_ng_paramFlg[iparam]) return;
    }

    if (type() == cEXCIT && V_rev() <= V_0()) return;
    if (type() == cINHIB && V_rev() >= V_0()) return;

    _ng_mp_decay_step = exp(-1 * time_step / tau_mbn());

    _ng_state = true;
}

bool NeurGrp::is_ready(void) const
{
    if (_ng_state) return true;

    for (TInt iparam = 0; iparam < NG_PARA_NUM; iparam++) {
        if (!_ng_paramFlg[iparam]) {
            cerr << name() << ": " << NG_ParamName[iparam] << " has not been set!\n";
            return false;
        }
    }

    if (type() == cNaN) {
        cerr << name() << ": type has not been set!\n";
        return false;
    }
    if (layer() < 0) {
        cerr << name() << ": layer has not been set!\n";
        return false;
    }

    if (type() == cEXCIT && V_rev() <= V_0()) {
        cerr << name() << ": the V_rev of excitatory neuron must be bigger than its V_0!\n";
        return false;
    }

    if (type() == cINHIB && V_rev() >= V_0()) {
        cerr << name() << ": the V_rev of excitatory neuron must be smaller than its V_0!\n";
        return false;
    }

    cerr << name() << ": the neuron group has not been initialized!\n";
    return false;
}

//return exp(-1.0*s*s/(2*sigma*sigma))/(2*PI*sigma*sigma);
//where sigma=ng_paramVal[NG_IDX_SYNP_SIGMA]
TReal NeurGrp::eqn_synp_ratio(const TReal& x, const TReal& y, const TReal& elmt_size) const
{
    TReal x_lower = x - 0.5*elmt_size;
    TReal x_upper = x_lower + elmt_size;

    TReal y_lower = y - 0.5*elmt_size;
    TReal y_upper = y_lower + elmt_size;

    //integrate
    return 0.25 * (erf(x_upper / (SQRT_2*_ng_paramVal[NG_IDX_SYNP_SIGMA]))
        - erf(x_lower / (SQRT_2*_ng_paramVal[NG_IDX_SYNP_SIGMA]))) *
        (erf(y_upper / (SQRT_2*_ng_paramVal[NG_IDX_SYNP_SIGMA]))
            - erf(y_lower / (SQRT_2*_ng_paramVal[NG_IDX_SYNP_SIGMA])));
}


string NeurGrp::print(vector<Layer> LyArry) const
{
    ostringstream oss;
    oss << "NEURON." << name() << "{" << "\n";
    oss << "\tTYPE" << " = " << neur2str(type()) << ";" << endl;
    oss << "\tLAYER" << " = " << Layer::idx2name(layer(), LyArry) << ";" << endl;
    for (TInt iparam = 0; iparam < NG_PARA_NUM; ++iparam) {
        oss << "\t" << NG_ParamName[iparam] << " = " << _ng_paramVal[iparam] << ";" << endl;
    }
    oss << "\t//MP DECAY @ STEP = " << _ng_mp_decay_step << endl;
    oss << "};\n";

    return oss.str();
}

string NeurGrp::print() const
{
    ostringstream oss;
    oss << "NEURON." << name() << "{" << "\n";
    oss << "\tTYPE = " << neur2str(type()) << ";" << endl;
    oss << "\t//LAYER = " << layer() << ";" << endl;
    oss << "\t//INDEX = " << index() << ";" << endl;
    for (TInt iparam = 0; iparam < NG_PARA_NUM; ++iparam) {
        oss << "\t" << NG_ParamName[iparam] << " = " << _ng_paramVal[iparam] << ";" << endl;
    }
    oss << "\t//MP DECAY @ STEP = " << _ng_mp_decay_step << endl;
    oss << "};\n";

    return oss.str();
}

bool ng_check_idx(const vector<NeurGrp> &NeurArry)
{
    if (NeurArry.empty()) return true;
    for (TInt idx = 0; idx < NeurArry.size(); idx++) {
        if (NeurArry[idx].index() != idx) {
            cerr << "Neuron group " << NeurArry[idx].name() << ": the index value is not consistent with the array index!\n";
            cerr << "**array index=" << idx << "; object index=" << NeurArry[idx].index() << "\n";
            return false;
        }
    }
    return true;
}
